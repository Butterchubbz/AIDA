import { spawn, ChildProcess } from 'child_process';
import * as path from 'path';
import * as fs from 'fs-extra';
import axios from 'axios';
import treeKill from 'tree-kill';
import { LauncherError, getErrorMessage } from '../utils/error-handler';
import { CONFIG } from '../utils/config';

export class AidaService {
    private process: ChildProcess | null = null;
    private readonly aidaPath: string;
    private port: number;

    constructor(aidaPath: string) {
        this.aidaPath = aidaPath;
        this.port = CONFIG.ports.aida;
    }

    async start(): Promise<number> {
        try {
            // The AIDA web app is now a bundled resource.
            const packageJsonPath = path.join(this.aidaPath, 'package.json');
            
            if (!fs.existsSync(packageJsonPath)) {
                throw new LauncherError('AIDA application not found in resources at ' + this.aidaPath, 'AIDA_NOT_FOUND');
            }

            await this.setupPocketbaseConfig();

            console.log('Starting AIDA from:', this.aidaPath);

            // The vite executable is also a bundled resource.
            const viteExecutable = path.join(this.aidaPath, 'node_modules', 'vite', 'bin', 'vite.js');
            if (!fs.existsSync(viteExecutable)) {
                throw new LauncherError('Vite executable not found. The AIDA web app dependencies may not be bundled correctly.', 'VITE_NOT_FOUND');
            }

            this.process = spawn('node', [viteExecutable, '--port', this.port.toString(), '--open', '/control-panel'], {
                cwd: this.aidaPath,
                shell: true,
                env: {
                    ...process.env,
                    BROWSER: 'none'
                }
            });

            await this.waitForReady();

            this.process.stdout?.on('data', (data) => {
                console.log('AIDA:', data.toString().trim());
            });

            this.process.stderr?.on('data', (data) => {
                console.error('AIDA Error:', data.toString().trim());
            });

            return this.port;
        } catch (error: unknown) {
            throw new LauncherError(`Failed to start AIDA: ${getErrorMessage(error)}`, 'START_FAILED');
        }
    }

    private async setupPocketbaseConfig(): Promise<void> {
        const libPath = path.join(this.aidaPath, 'src', 'lib');
        const configPath = path.join(libPath, 'pocketbase.js');
        await fs.ensureDir(libPath);
        const configContent = `
            // This file is dynamically generated by the AIDA launcher.
            let pocketbaseInstance = null;
            export default async function getPocketBase() {
                if (!pocketbaseInstance) {
                    const { default: PocketBase } = await import('pocketbase');
                    pocketbaseInstance = new PocketBase('http://127.0.0.1:${CONFIG.ports.pocketbase}');
                }
                return pocketbaseInstance;
            }
        `;
        await fs.writeFile(configPath, configContent.trim());
    }

    private async pollForServerReady(port: number, retries = 10, delay = 500): Promise<void> {
        for (let i = 0; i < retries; i++) {
            try {
                await axios.get(`http://localhost:${port}`);
                console.log('AIDA is ready.');
                return;
            } catch (error) {
                if (i === retries - 1) {
                    throw new LauncherError(`AIDA started on port ${port} but is not responding: ${getErrorMessage(error)}`, 'NOT_RESPONDING');
                }
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    private async waitForReady(): Promise<void> {
        const stripAnsi = (await import('strip-ansi')).default;
        return new Promise((resolve, reject) => {
            if (!this.process) {
                return reject(new LauncherError('AIDA process not spawned', 'PROCESS_NOT_SPAWNED'));
            }

            const timeout = setTimeout(() => {
                cleanup();
                reject(new LauncherError('AIDA failed to start within 30 seconds.', 'TIMEOUT'));
            }, 30000);

            let buffer = '';
            let portFound = false;
            const onData = (data: Buffer) => {
                if (portFound) return;

                const cleanOutput = stripAnsi(data.toString());
                buffer += cleanOutput;

                console.log('AIDA:', cleanOutput.trim());

                const portMatch = buffer.match(/http:\/\/localhost:(\d+)/);
                if (portMatch) {
                    portFound = true;
                    this.port = parseInt(portMatch[1], 10);
                    console.log(`AIDA detected running on port ${this.port}`);
                    cleanup();
                    
                    this.pollForServerReady(this.port)
                        .then(resolve)
                        .catch(reject);
                }
            };

            const cleanup = () => {
                clearTimeout(timeout);
                this.process?.stdout?.removeListener('data', onData);
                this.process?.stderr?.removeListener('data', onData);
            };

            this.process.stdout?.on('data', onData);
            this.process.stderr?.on('data', onData);
        });
    }

    public stop(): Promise<void> {
        return new Promise((resolve, reject) => {
            if (!this.process || !this.process.pid) {
                this.process = null;
                return resolve();
            }

            treeKill(this.process.pid, 'SIGKILL', (err) => {
                if (err) {
                    console.error('Failed to kill AIDA process tree:', err);
                    reject(err);
                } else {
                    console.log('AIDA process tree killed successfully.');
                    this.process = null;
                    resolve();
                }
            });
        });
    }

    public getPort(): number {
        return this.port;
    }
}